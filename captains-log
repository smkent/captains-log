#!/usr/bin/env python

from __future__ import print_function

import argparse
import datetime
import os
import subprocess
import sys
import tempfile

VERSION_FILE = '.captains-log'
VERSION_FILE_CONTENTS = '0'
DEFAULT_DATA_DIR = os.path.join(os.path.expanduser('~'),
                                '.smkent', 'captains-log')


class CaptainsLog():
    def main(self):
        self.parse_arguments()
        self.check_or_create_log_dir(create=not self.args.read)
        if self.args.read:
            # Display existing log entries
            self.read_log()
        self.write_log()

    def parse_arguments(self):
        description = 'Captain\'s Log'
        ap = argparse.ArgumentParser(description=description)
        ap.add_argument('-d', '-f', '--date', '--from-date', dest='date',
                        metavar='date')
        ap.add_argument('-u', '--until-date', dest='until_date',
                        metavar='date')
        ap.add_argument('-r', '--read', dest='read', action='store_true',
                        help='Print the log entry for today')
        ap.add_argument('-n', '-n', dest='num', metavar='num', default=0,
                        help='Number of log entries to show')
        ap.add_argument('-m', '--message', dest='message', metavar='message',
                        help='Log message to append')
        ap.add_argument('text', nargs='*', help='Command or log text')
        self.args = ap.parse_args()
        # Validate arguments
        if self.args.num > 0:
            self.args.read = True
        # Parse positional command line arguments
        if self.args.text:
            self.parse_positional_arguments()

    def parse_positional_arguments(self):
        if not self.args.read:
            for word in ['read', 'log']:
                if word.startswith(self.args.text[0]):
                    self.args.read = True
                    self.args.text.pop(0)
                    if not len(self.args.text):
                        return
                    break
        if not self.args.date:
            try:
                # If a date is specified, show only the log for that specific
                # date
                self.args.text_date = self.parse_date(' '.join(self.args.text))
                self.args.date = self.args.text_date
                self.args.until_date = self.args.text_date
                self.args.read = True
                return
            except subprocess.CalledProcessError:
                pass
        if (self.args.text[0].startswith('-') and
                self.args.text[0][1:].isdigit()):
            self.args.read = True
            self.args.num = int(self.args.text.pop()[1:])
            if not len(self.args.text):
                return
        if not self.args.read and not self.args.message:
            self.args.message = ' '.join(self.args.text)
            return
        raise Exception(('Unrecognized arguments: '
                         '{}').format(' '.join(self.args.text)))

    def read_log(self):
        if self.args.date:
            from_date = self.parse_date(self.args.date)
        else:
            from_date = self.find_start_end_log_date(start=True) or \
                datetime.datetime.today()
        if self.args.until_date:
            until_date = self.parse_date(self.args.until_date)
        else:
            until_date = self.find_start_end_log_date(start=False) or \
                datetime.datetime.today()

        first = True
        count = 0
        p = subprocess.Popen(['less', '-X', '-R', '-F', '-'],
                             stdin=subprocess.PIPE)
        min_check = None
        for i in range((until_date - from_date).days, -1, -1):
            log_date = from_date + datetime.timedelta(days=i)
            if min_check:
                if min_check < log_date:
                    continue
            if not os.path.isdir(str(log_date.year)):
                min_check = datetime.datetime(log_date.year - 1, 12, 31)
                continue
            if not os.path.isdir(log_date.strftime('%Y/%m')):
                min_check = datetime.datetime(log_date.year, log_date.month, 1)
                min_check -= datetime.timedelta(days=1)
                continue
            lf = log_date.strftime('%Y/%m/%d')
            if not os.path.isfile(lf):
                continue
            if not first:
                print(file=p.stdin)
            display_date = self.format_display_date(log_date)
            print('>> {}{}'.format(display_date, os.linesep), file=p.stdin)
            with open(lf, 'r') as f:
                print(os.linesep.join(['    {}'.format(x) for x in
                                       f.read().strip().splitlines()]),
                      file=p.stdin)
            first = False
            count += 1
            if self.args.num > 0 and count >= self.args.num:
                break
        p.stdin.flush()
        p.communicate()
        sys.exit(0)

    def write_log(self):
        log_date = self.parse_date(self.args.date, grace=True)
        display_date = self.format_display_date(log_date)
        log_file = log_date.strftime('%Y/%m/%d')

        log_dir = os.path.dirname(log_file)
        if not os.path.isdir(log_dir):
            os.makedirs(log_dir, 0o0700)

        log_entry = None
        log_append = False
        existing_entry = self.get_log_entry(log_date)
        if self.args.message is not None:
            log_entry = self.args.message
            log_append = True
        else:
            with tempfile.NamedTemporaryFile() as f:
                if existing_entry:
                    f.write(existing_entry)
                f.write(os.linesep * 2)
                print('# Log entry for {}'.format(display_date), file=f)
                print('# Add your log entry above', file=f)
                print('# Lines starting with \'#\' will be ignored', file=f)
                print('#', file=f)
                print('# vim: ft=gitcommit', file=f)
                f.flush()
                subprocess.check_call([os.environ.get('EDITOR'), f.name])
                f.seek(0, 0)
                lines = f.readlines()
                entry_lines = []
                for line in lines:
                    if line.startswith('#'):
                        continue
                    entry_lines.append(line.strip())
                log_entry = os.linesep.join(entry_lines).strip()

        if log_entry == existing_entry:
            print('Log entry unmodified.', file=sys.stderr)
            return

        if not log_entry:
            print('No log entry entered, no changes made.', file=sys.stderr)
            return

        print('Writing log entry: [{}]'.format(log_entry))
        log_exists = os.path.isfile(log_file)
        with open(log_file, 'a' if log_append else 'w') as f:
            if log_append:
                f.write(os.linesep)
            f.write(log_entry)
            f.write(os.linesep)
        git_status = subprocess.check_output(['git', 'status', '--short',
                                              '--', log_file]).strip()
        if git_status:
            subprocess.check_call(['git', 'add', '--', log_file])
            message = '{} log for {}'.format('Update' if log_exists else
                                             'Create',
                                             display_date)
            subprocess.check_call(['git', 'commit', '-m', message])
        else:
            print('No changes to commit.')

    def check_or_create_log_dir(self, create=False):
        if not os.path.isdir(DEFAULT_DATA_DIR):
            os.makedirs(DEFAULT_DATA_DIR, 0o0700)
        os.chdir(DEFAULT_DATA_DIR)
        if os.path.isfile(VERSION_FILE):
            with open(VERSION_FILE, 'r') as f:
                if f.read().strip() != VERSION_FILE_CONTENTS:
                    raise Exception('Log storage version mismatch')
            if not os.path.isdir('.git'):
                raise Exception('The log repository is missing')
        else:
            if not create:
                raise Exception('Directory does not contain a log')
            if os.path.isdir('.git'):
                raise Exception('There is an existing repository in this '
                                'directory')
            subprocess.check_call(['git', 'init'])
            with open(VERSION_FILE, 'w') as f:
                f.write(VERSION_FILE_CONTENTS)
            subprocess.check_call(['git', 'add', VERSION_FILE])
            subprocess.check_call(['git', 'commit', '-m',
                                   'Create new log directory'])

    def get_log_entry(self, log_date):
        log_file = log_date.strftime('%Y/%m/%d')
        if not os.path.isfile(log_file):
            return None
        with open(log_file, 'r') as f:
            return f.read().strip()

    def parse_date(self, parse_date, grace=False):
        if not parse_date:
            if grace:
                return datetime.datetime.today() - datetime.timedelta(hours=2)
            return datetime.datetime.today()
        cmd = ['date', '+%s', '--date={}'.format(parse_date)]
        output = subprocess.check_output(cmd, stderr=open('/dev/null', 'w'))
        return datetime.datetime.fromtimestamp(float(output))

    def format_display_date(self, date):
        return date.strftime('%A, %B %-d, %Y')

    def find_start_end_log_date(self, start=True):
        # Recurse into year and month directories in order to find the earliest
        # dated log entry
        def _log_entry_search(search_dir, min_length=1, level=2):
            dir_contents = sorted(os.listdir(search_dir), reverse=not start)
            for i in dir_contents:
                if len(i) < min_length or not i.isdigit():
                    continue
                if level > 0:
                    l = _log_entry_search(os.path.join(search_dir, i),
                                          level=(level - 1))
                    if not l:
                        continue
                    return l + [int(i)]
                else:
                    return [int(i)]
            return None
        log_date = _log_entry_search('.', 4)
        if not log_date:
            return None
        return datetime.datetime(log_date[2], log_date[1], log_date[0])


def main():
    try:
        cl = CaptainsLog()
        cl.main()
    except Exception as e:
        print('Error: {}'.format(str(e)), file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
